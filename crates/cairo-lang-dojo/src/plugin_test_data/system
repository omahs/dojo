//! > Test expansion of the component contract.

//! > test_function_name
test_expand_contract

//! > cairo_code
extern type Query<T>;

#[component]
mod PositionComponent {
    struct Position {
        x: felt,
        y: felt,
    }
}

#[component]
mod HealthComponent {
    struct Health {
        hp: felt,
    }
}

#[system]
mod MoveSystem {
    use PositionComponent::Position;
    use HealthComponent::Health;

    fn execute_inner(query: Query::<(Position, Option::<Health>)>) {
        return ();
    }

    fn execute(world: felt, query: Query::<(Position, Option::<Health>)>) {
        return ();
    }
}

//! > generated_cairo_code
struct Position {
    x: felt,
    y: felt,
}

impl PositionSerde of Serde::<Position> {
    fn serialize(ref serialized: Array::<felt>, input: Position) {
        Serde::<felt>::serialize(ref serialized, input.x);
        Serde::<felt>::serialize(ref serialized, input.y);
    }
    fn deserialize(ref serialized: Array::<felt>) -> Option::<Position> {
        Option::Some(
            Position {
                x: Serde::<felt>::deserialize(ref serialized)?,
                y: Serde::<felt>::deserialize(ref serialized)?,
            }
        )
    }
}

impl StorageAccessPosition of StorageAccess::<Position> {
    fn read(address_domain: felt, base: StorageBaseAddress) -> SyscallResult::<Position> {
        Result::Ok(
            Position {
                x: storage_read_syscall(
                    address_domain, storage_address_from_base_and_offset(base, 0_u8)
                )?,
                y: storage_read_syscall(
                    address_domain, storage_address_from_base_and_offset(base, 1_u8)
                )?,
            }
        )
    }
    fn write(
        address_domain: felt, base: StorageBaseAddress, value: Position
    ) -> SyscallResult::<()> {
        storage_write_syscall(
            address_domain, storage_address_from_base_and_offset(base, 0_u8), value.x
        );
        storage_write_syscall(
            address_domain, storage_address_from_base_and_offset(base, 1_u8), value.y
        );
    }
}

#[contract]
mod PositionComponent {
    struct Storage {
        world_address: felt,
        state: Map::<felt, Position>,
    }

    // Initialize PositionComponent.
    #[external]
    fn initialize(world_addr: felt) {
        let world = world_address::read();
        assert(world == 0, 'PositionComponent: Already initialized.');
        world_address::write(world_addr);
    }

    // Set the state of an entity.
    #[external]
    fn set(entity_id: felt, value: Position) {
        state::write(entity_id, value);
    }

    // Get the state of an entity.
    #[view]
    fn get(entity_id: felt) -> Position {
        return state::read(entity_id);
    }
}

struct Health {
    hp: felt, 
}

impl HealthSerde of Serde::<Health> {
    fn serialize(ref serialized: Array::<felt>, input: Health) {
        Serde::<felt>::serialize(ref serialized, input.hp);
    }
    fn deserialize(ref serialized: Array::<felt>) -> Option::<Health> {
        Option::Some(Health { hp: Serde::<felt>::deserialize(ref serialized)?,  })
    }
}

impl StorageAccessHealth of StorageAccess::<Health> {
    fn read(address_domain: felt, base: StorageBaseAddress) -> SyscallResult::<Health> {
        Result::Ok(
            Health {
                hp: storage_read_syscall(
                    address_domain, storage_address_from_base_and_offset(base, 0_u8)
                )?,
            }
        )
    }
    fn write(address_domain: felt, base: StorageBaseAddress, value: Health) -> SyscallResult::<()> {
        storage_write_syscall(
            address_domain, storage_address_from_base_and_offset(base, 0_u8), value.hp
        );
    }
}

#[contract]
mod HealthComponent {
    struct Storage {
        world_address: felt,
        state: Map::<felt, Health>,
    }

    // Initialize HealthComponent.
    #[external]
    fn initialize(world_addr: felt) {
        let world = world_address::read();
        assert(world == 0, 'HealthComponent: Already initialized.');
        world_address::write(world_addr);
    }

    // Set the state of an entity.
    #[external]
    fn set(entity_id: felt, value: Health) {
        state::write(entity_id, value);
    }

    // Get the state of an entity.
    #[view]
    fn get(entity_id: felt) -> Health {
        return state::read(entity_id);
    }
}

#[contract]
mod MoveSystem {
    use PositionComponent::Position;
    use HealthComponent::Health;

    fn execute_inner(query: Query::<(Position, Option::<Health>)>) {
        return ();
    }
    struct Storage {
        world_address: felt, 
    }

    #[external]
    fn initialize(world_addr: felt) {
        let world = world_address::read();
        assert(world == 0, 'MoveSystem: Already initialized.');
        world_address::write(world_addr);
    }

    #[external]
    fn execute() {
        let world = world_address::read();
        assert(world != 0, 'MoveSystem: Not initialized.');

        let position_ids = IWorld.lookup(
            world, 0x28b9aeb6b19af1454b16ce28c1ee6909e3946e4552ed09886a06ebe1e158fc
        );
        let health_ids = IWorld.lookup(
            world, 0x18aab326bea0fdf2117dc4f32e8cf0ee59a1177415f6c7bc5e1ac210048bf63
        );

        return ();
    }
}

//! > expected_diagnostics
